Client â†’ Login API
   â†“
Auth Service validates credentials
   â†“
JWT generated (roles embedded)
   â†“
Client sends JWT in Authorization header
   â†“
Other services validate JWT (NO DB call)

auth-service/
 â”œâ”€â”€ config
 â”‚   â”œâ”€â”€ SecurityConfig.java
 â”‚   â”œâ”€â”€ JwtUtil.java
 â”‚   â””â”€â”€ JwtAuthFilter.java
 â”‚
 â”œâ”€â”€ controller
 â”‚   â””â”€â”€ AuthController.java
 â”‚
 â”œâ”€â”€ service
 â”‚   â”œâ”€â”€ AuthService.java
 â”‚   â””â”€â”€ impl/AuthServiceImpl.java
 â”‚
 â”œâ”€â”€ domain
 â”‚   â”œâ”€â”€ User.java
 â”‚   â”œâ”€â”€ Role.java
 â”‚   â””â”€â”€ UserRole.java
 â”‚
 â”œâ”€â”€ repository
 â”‚   â”œâ”€â”€ UserRepository.java
 â”‚   â””â”€â”€ RoleRepository.java
 â”‚
 â”œâ”€â”€ dto
 â”‚   â”œâ”€â”€ LoginRequest.java
 â”‚   â”œâ”€â”€ RegisterRequest.java
 â”‚   â””â”€â”€ AuthResponse.java
 â”‚
 â””â”€â”€ AuthServiceApplication.java

Why ManyToMany?

Users can have multiple roles

Roles are reusable

ðŸ”¹ Why EAGER fetch?

Roles are required every time for JWT

Avoids lazy-loading issues during auth

ðŸ”¹ Why UUID for User ID?

Safe for distributed systems

No predictable IDs

Login Request
 â†’ Spring Security
 â†’ UserDetailsService.loadUserByUsername()
 â†’ Fetch user from DB
 â†’ Convert User â†’ UserDetails
 â†’ Password match (BCrypt)
 â†’ Authentication success/failure
